# RustOS-lab5 实验报告

陈张萌 2017013678 计74

[TOC]

## 本次实验增加了什么？

1. 模仿Pipe，增加了用于存储mail的文件格式：MPipe。每条MPipe和Pipe的区别在于：
   1. 增大了buffer的大小
   2. 在pipe中，如果pipe已经满了，那么就切换进程，但是在mpipe中如果满了，那就放弃写操作，返回写邮件失败
2. 每个Mail类存储的是新建的MPipe如果分配文件描述符成功，那么存储读邮件的文件描述符。写文件的描述符不需要存储，因为每条邮件只写一次，写完之后直接关闭写端即可。
3. 每个进程控制块分配一个mailbox，每个mailbox实现为一个FIFO的mail队列，记录了读邮件的文件描述符都有哪些。邮箱是否满、是否空都由mailbox确定。
4. 系统调用实现如下（mail_write为例，错误处理过于繁琐，不在此描述）：
   1. 新建一个MPipe，返回读端和写端
   2. 目标进程分配一个文件描述符，保存读端
   3. 当前进程分配一个文件描述符，保存写端
   4. 执行sys_write系统调用
   5. 执行sys_close关闭写端

运行测例，输出结果如下：

![](./lab6/result.png)

## 简答作业

### 问题1

> 举出使用 pipe 的一个实际应用的例子。

用于进程间通信。

### 问题2

> 假设我们的邮箱现在有了更加强大的功能，容量大幅增加而且记录邮件来源，可以实现“回信”。考虑一个多核场景，有 m 个核为消费者，n 个为生产者，消费者通过邮箱向生产者提出订单，生产者通过邮箱回信给出产品。

#### 问题2-1

> 假设你的邮箱实现没有使用锁等机制进行保护，在多核情景下可能会发生哪些问题？单核一定不会发生问题吗？为什么？



#### 问题2-2

> 请结合你在课堂上学到的内容，描述读者写者问题的经典解决方案，必要时提供伪代码。



#### 问题2-3

> 由于读写是基于报文的，不是随机读写，你有什么点子来优化邮箱的实现吗？





## 你对本次实验设计及难度/工作量的看法，以及有哪些需要改进的地方

